<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Bonaco Editor</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body, html {
      height: 100%;
      overflow: hidden;
      background: #050505;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    #tab-bar {
      display: flex;
      background: #050505;
      height: 42px;
      align-items: center;
      padding: 0 8px;
      border-bottom: 1px solid #323232;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
      position: relative;
      overflow-x: auto;
      overflow-y: hidden;
    }

    .tab {
      padding: 0 16px;
      height: 32px;
      line-height: 32px;
      color: #909090;
      cursor: pointer;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      user-select: none;
      margin-right: 6px;
      flex-shrink: 0;
      position: relative;
      min-width: 80px;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid transparent;
    }

    .tab:hover {
      color: #c0c0c0;
      background: rgba(50, 50, 50, 0.1);
      border-color: rgba(50, 50, 50, 0.3);
    }

    .tab.active {
      color: #ffffff;
      background: -webkit-linear-gradient(135deg, rgba(50, 50, 50, 0.2) 0%, rgba(60, 60, 60, 0.15) 100%);
      border-color: rgba(50, 50, 50, 0.5);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    .tab.active::before {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      height: 2px;
      background: -webkit-linear-gradient(90deg, transparent 0%, #606060 50%, transparent 100%);
      border-radius: 1px;
    }

    .tab.new {
      padding: 0 12px;
      font-size: 18px;
      color: #707070;
      font-weight: 600;
      background: rgba(50, 50, 50, 0.08);
      border-color: rgba(50, 50, 50, 0.2);
      min-width: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .tab.new:hover {
      color: #808080;
      background: rgba(50, 50, 50, 0.15);
      border-color: rgba(50, 50, 50, 0.4);
    }

    .tab[contenteditable="true"] {
      outline: 2px solid #606060;
      background: -webkit-linear-gradient(135deg, #2a2a2a 0%, #3a3a3a 100%);
      color: #fff;
      box-shadow: 0 0 0 1px rgba(50, 50, 50, 0.3), 0 4px 16px rgba(0, 0, 0, 0.5);
    }

    .tab .close-tab {
      margin-left: 8px;
      color: #909090;
      font-size: 14px;
      cursor: pointer;
      line-height: 1;
    }

    .tab .close-tab:hover {
      color: #c0c0c0;
    }

    #editor-container {
      position: absolute;
      top: 42px;
      bottom: 0;
      left: 0;
      right: 0;
      border-radius: 0;
      overflow: hidden;
    }

    #context-menu {
      position: absolute;
      background: -webkit-linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
      color: #fff;
      border: 1px solid rgba(50, 50, 50, 0.3);
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7), 0 2px 8px rgba(50, 50, 50, 0.2);
      display: none;
      z-index: 1000;
      overflow: hidden;
      min-width: 120px;
    }

    #context-menu::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: -webkit-linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.05) 50%, transparent 100%);
    }

    #context-menu div {
      padding: 12px 16px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      white-space: nowrap;
      position: relative;
    }

    #context-menu div:hover {
      background: -webkit-linear-gradient(90deg, rgba(50, 50, 50, 0.2) 0%, rgba(60, 60, 60, 0.15) 100%);
      color: #fff;
      padding-left: 20px;
    }

    #context-menu div:first-child:hover {
      border-radius: 12px 12px 0 0;
    }

    #context-menu div:last-child:hover {
      border-radius: 0 0 12px 12px;
    }

    #context-menu div:only-child:hover {
      border-radius: 12px;
    }

    /* Scrollbar styling */
    #tab-bar::-webkit-scrollbar {
      height: 4px;
    }

    #tab-bar::-webkit-scrollbar-track {
      background: transparent;
    }

    #tab-bar::-webkit-scrollbar-thumb {
      background: rgba(50, 50, 50, 0.3);
      border-radius: 2px;
    }

    #tab-bar::-webkit-scrollbar-thumb:hover {
      background: rgba(50, 50, 50, 0.5);
    }
  </style>
</head>
<body>
  <div id="tab-bar"></div>
  <div id="editor-container"></div>

  <div id="context-menu">
    <div data-action="rename">Rename</div>
    <div data-action="delete">Delete</div>
  </div>

  <script>
    // Load Monaco editor
    var require = { paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.20.0/min/vs' } };
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.20.0/min/vs/loader.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.20.0/min/vs/editor/editor.main.nls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.20.0/min/vs/editor/editor.main.js"></script>
  
  <script>
    require(['vs/editor/editor.main'], function() {
      // Monaco theme
      monaco.editor.defineTheme('gray-black', {
        base: 'vs-dark', 
        inherit: true, 
        rules: [
          { token: '', foreground: '#E0E0E0' },
          { token: 'comment', foreground: '#888888' },
          { token: 'keyword', foreground: '#C0C0C0' },
          { token: 'number', foreground: '#A0A0A0' },
          { token: 'string', foreground: '#D0D0D0' },
          { token: 'delimiter', foreground: '#E0E0E0' },
          { token: 'operator', foreground: '#C0C0C0' },
          { token: 'function', foreground: '#B0B0B0' },
          { token: 'identifier', foreground: '#E0E0E0' },
          { token: 'type', foreground: '#C0C0C0' },
          { token: 'variable', foreground: '#B0B0B0' },
          { token: 'global', foreground: '#A0A0A0' },
          { token: 'library', foreground: '#C0C0C0' },
          { token: 'constant', foreground: '#A0A0A0' },
          { token: 'predefined', foreground: '#C0C0C0' },
          { token: 'support.function', foreground: '#C0C0C0' },
          { token: 'support.class', foreground: '#A0A0A0' }
        ], 
        colors: {
          'editor.background': '#050505',
          'editorLineNumber.foreground': '#666666',
          'editorCursor.foreground': '#CCCCCC',
          'minimap.background': '#050505',
          'minimap.slider.background': '#80808080',
          'minimap.slider.hoverBackground': '#808080AA',
          'editor.foreground': '#E0E0E0',
          'editor.selectionBackground': '#303030',
          'editor.inactiveSelectionBackground': '#30303080',
          'editor.lineHighlightBackground': '#30303050',
          'editorIndentGuide.background': '#303030',
          'editorWhitespace.foreground': '#202020',
          'editorSuggestWidget.background': '#1a1a1a',
          'editorSuggestWidget.border': '#505050',
          'editorSuggestWidget.selectedBackground': '#303030',
          'editorError.foreground': '#FF6666',
          'editorWarning.foreground': '#FFFF66',
          'editorInfo.foreground': '#66CCFF'
        }
      });
      
      monaco.editor.setTheme('gray-black');
      
      // Variable tracking
      function extractVariablesAndFunctions(code) {
        var variables = new Set();
        var functions = new Set();
        var lines = code.split('\n');

        for (var i = 0; i < lines.length; i++) {
          var line = lines[i];
          var match;
          var localVarPattern = /local\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:=\s*.*)?/g;
          while ((match = localVarPattern.exec(line)) !== null) {
            variables.add(match[1]);
          }

          var assignmentPattern = /([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*.*(?<!==)(?<!~=)(?<!<=)(?<!>=)/g;
          while ((match = assignmentPattern.exec(line)) !== null) {
            variables.add(match[1]);
          }

          var funcPattern = /(?:local\s+)?function\s+([a-zA-Z_][a-zA-Z0-9_]*)(?:\s*\(.*?\))?/g;
          while ((match = funcPattern.exec(line)) !== null) {
            functions.add(match[1]);
          }

          var paramPattern = /function\s*[a-zA-Z_][a-zA-Z0-9_]*\s*\((.*?)\)/;
          var paramsMatch = line.match(paramPattern);
          if (paramsMatch && paramsMatch[1]) {
            paramsMatch[1].split(',').forEach(function(param) {
              var trimmedParam = param.trim().split(':')[0].trim();
              if (trimmedParam) {
                variables.add(trimmedParam);
              }
            });
          }

          var forLoopPattern = /for\s+([a-zA-Z_][a-zA-Z0-9_]*)(?:\s*,\s*([a-zA-Z_][a-zA-Z0-9_]*))?\s*(?:in|=)/g;
          while ((match = forLoopPattern.exec(line)) !== null) {
            variables.add(match[1]);
            if (match[2]) {
              variables.add(match[2]);
            }
          }
        }

        return { variables: Array.from(variables), functions: Array.from(functions) };
      }

      // Syntax checking
      function checkLuaSyntax(code) {
        var errors = [];
        var lines = code.split('\n');
        var endStack = [];

        for (var i = 0; i < lines.length; i++) {
          var line = lines[i];
          var trimmedLine = line.trim();
          var lineNum = i + 1;

          var openBrackets = (line.match(/\[/g) || []).length;
          var closeBrackets = (line.match(/\]/g) || []).length;
          var openParens = (line.match(/\(/g) || []).length;
          var closeParens = (line.match(/\)/g) || []).length;

          if (openBrackets !== closeBrackets) {
            errors.push({
              startLineNumber: lineNum,
              endLineNumber: lineNum,
              startColumn: 1,
              endColumn: line.length + 1,
              message: 'Unmatched square brackets on this line. Check for missing `[` or `]`.',
              severity: monaco.MarkerSeverity.Error
            });
          }

          if (openParens !== closeParens) {
            errors.push({
              startLineNumber: lineNum,
              endLineNumber: lineNum,
              startColumn: 1,
              endColumn: line.length + 1,
              message: 'Unmatched parentheses on this line. Check for missing `(` or `)`.',
              severity: monaco.MarkerSeverity.Error
            });
          }

          if (trimmedLine.startsWith('if ') && !/\sthen\b/.test(trimmedLine) && !trimmedLine.includes('--')) {
            errors.push({
              startLineNumber: lineNum,
              endLineNumber: lineNum,
              startColumn: 1,
              endColumn: line.length + 1,
              message: 'Missing "then" after "if" statement. Example: `if condition then`',
              severity: monaco.MarkerSeverity.Error
            });
          }
          
          if (trimmedLine.startsWith('for ') && !/\sdo\b/.test(trimmedLine) && !/\s=/.test(trimmedLine) && !trimmedLine.includes('--')) {
            errors.push({
              startLineNumber: lineNum,
              endLineNumber: lineNum,
              startColumn: 1,
              endColumn: line.length + 1,
              message: 'Missing "do" after "for" loop declaration. For numeric loops, ensure assignment (e.g., `for i = 1, 10 do`). For iterators, use `in` (e.g., `for i, v in pairs(tbl) do`).',
              severity: monaco.MarkerSeverity.Error
            });
          }
          
          if (trimmedLine.startsWith('while ') && !/\sdo\b/.test(trimmedLine) && !trimmedLine.includes('--')) {
            errors.push({
              startLineNumber: lineNum,
              endLineNumber: lineNum,
              startColumn: 1,
              endColumn: line.length + 1,
              message: 'Missing "do" after "while" loop condition. Example: `while condition do`',
              severity: monaco.MarkerSeverity.Error
            });
          }

          var blockStarters = /\b(if|for|while|function|do)\b/g;
          var match;
          while ((match = blockStarters.exec(trimmedLine)) !== null) {
              endStack.push({ type: match[1], line: lineNum, column: match.index + 1 });
          }

          if (/\brepeat\b/.test(trimmedLine)) {
              endStack.push({ type: 'repeat', line: lineNum, column: trimmedLine.indexOf('repeat') + 1 });
          } else if (/\bend\b/.test(trimmedLine)) {
              if (endStack.length > 0) {
                  endStack.pop();
              } else {
                  errors.push({
                      startLineNumber: lineNum,
                      endLineNumber: lineNum,
                      startColumn: trimmedLine.indexOf('end') + 1,
                      endColumn: trimmedLine.indexOf('end') + 4,
                      message: 'Unmatched "end". This "end" might not have a corresponding block (if, for, while, function, do, repeat).',
                      severity: monaco.MarkerSeverity.Error
                  });
              }
          } else if (/\buntil\b/.test(trimmedLine)) {
              if (endStack.length > 0 && endStack[endStack.length - 1].type === 'repeat') {
                  endStack.pop();
              } else {
                  errors.push({
                      startLineNumber: lineNum,
                      endLineNumber: lineNum,
                      startColumn: trimmedLine.indexOf('until') + 1,
                      endColumn: trimmedLine.indexOf('until') + 6,
                      message: 'Unmatched "until". This "until" might not have a corresponding "repeat" statement.',
                      severity: monaco.MarkerSeverity.Error
                  });
              }
          }

          var incompleteAssignment = /^\s*(local\s+[a-zA-Z_][a-zA-Z0-9_]*\s*=\s*$|[a-zA-Z_][a-zA-Z0-9_]*\s*=\s*$)/;
          if (incompleteAssignment.test(trimmedLine)) {
            errors.push({
              startLineNumber: lineNum,
              endLineNumber: lineNum,
              startColumn: trimmedLine.match(incompleteAssignment).index + 1,
              endColumn: line.length + 1,
              message: 'Incomplete assignment. Expected a value after "=". Example: `local x = 10`',
              severity: monaco.MarkerSeverity.Error
            });
          }

          var trailingOperator = /[+\-*/%^&|~=<>,]\s*$/;
          if (trailingOperator.test(trimmedLine) && !trimmedLine.includes('--')) {
              errors.push({
                  startLineNumber: lineNum,
                  endLineNumber: lineNum,
                  startColumn: trimmedLine.match(trailingOperator).index + 1,
                  endColumn: line.length + 1,
                  message: 'Expression ends with an operator. Expected a value after the operator.',
                  severity: monaco.MarkerSeverity.Error
              });
          }

          if (/\blocal\s*$/.test(trimmedLine)) {
              errors.push({
                  startLineNumber: lineNum,
                  endLineNumber: lineNum,
                  startColumn: trimmedLine.indexOf('local') + 1,
                  endColumn: line.length + 1,
                  message: 'Missing variable name after "local". Example: `local myVariable`',
                  severity: monaco.MarkerSeverity.Error
              });
          }

          if (/\blocal\s+([a-zA-Z_][a-zA-Z0-9_]*)\.[a-zA-Z_][a-zA-Z0-9_]*/.test(trimmedLine)) {
              errors.push({
                  startLineNumber: lineNum,
                  endLineNumber: lineNum,
                  startColumn: trimmedLine.match(/\blocal\s+([a-zA-Z_][a-zA-Z0-9_]*)\.[a-zA-Z_][a-zA-Z0-9_]*/).index + 1,
                  endColumn: line.length + 1,
                  message: 'Cannot declare local variables with dotted names (e.g., `local game.Players` is invalid).',
                  severity: monaco.MarkerSeverity.Error
              });
          }

          if (/\bfunction\s*(?![a-zA-Z_][a-zA-Z0-9_]*\s*\(.*\))/.test(trimmedLine) && !trimmedLine.includes('--')) {
            var funcIndex = trimmedLine.indexOf('function');
            if (funcIndex !== -1) {
              var restOfLine = trimmedLine.substring(funcIndex + 'function'.length).trim();
              if (!restOfLine.match(/^[a-zA-Z_][a-zA-Z0-9_]*\s*\(.*\)$/)) {
                errors.push({
                  startLineNumber: lineNum,
                  endLineNumber: lineNum,
                  startColumn: funcIndex + 1,
                  endColumn: line.length + 1,
                  message: 'Malformed function declaration. Expected `function name(...)` or `local function name(...)`.',
                  severity: monaco.MarkerSeverity.Error
                });
              }
            }
          }

          var repeatedKeywordPatterns = [
              { pattern: /\blocal\s+local\b/g, message: 'Invalid syntax: "local" cannot be followed by "local". Expected a variable name or function declaration.' },
              { pattern: /\bfunction\s+function\b/g, message: 'Invalid syntax: "function" cannot be followed by "function". Expected a function name.' },
              { pattern: /\bend\s+end\b/g, message: 'Invalid syntax: "end" cannot be followed by "end". This usually indicates an extra "end".' },
              { pattern: /\bif\s+if\b/g, message: 'Invalid syntax: "if" cannot be followed by "if". Expected a condition.' },
              { pattern: /\bfor\s+for\b/g, message: 'Invalid syntax: "for" cannot be followed by "for". Expected a loop variable or iteration.' },
              { pattern: /\bwhile\s+while\b/g, message: 'Invalid syntax: "while" cannot be followed by "while". Expected a condition.' },
              { pattern: /\bdo\s+do\b/g, message: 'Invalid syntax: "do" cannot be followed by "do".' },
              { pattern: /\brepeat\s+repeat\b/g, message: 'Invalid syntax: "repeat" cannot be followed by "repeat".' },
              { pattern: /\bthen\s+then\b/g, message: 'Invalid syntax: "then" cannot be followed by "then".' },
              { pattern: /\belse\s+else\b/g, message: 'Invalid syntax: "else" cannot be followed by "else".' },
              { pattern: /\belseif\s+elseif\b/g, message: 'Invalid syntax: "elseif" cannot be followed by "elseif".' },
              { pattern: /\bgetgenv\s+getgenv\b/g, message: 'Invalid syntax: "getgenv" cannot be followed by "getgenv".' },
              { pattern: /\bgame\s+game\b/g, message: 'Invalid syntax: "game" cannot be followed by "game". Did you mean `game.Workspace` or `game:GetService()`?' },
              { pattern: /\bworkspace\s+workspace\b/g, message: 'Invalid syntax: "workspace" cannot be followed by "workspace". Did you mean `workspace.Part`?' },
              { pattern: /\bscript\s+script\b/g, message: 'Invalid syntax: "script" cannot be followed by "script". Did you mean `script.Parent`?' }
          ];

          repeatedKeywordPatterns.forEach(function(item) {
              var repetitionMatch;
              while ((repetitionMatch = item.pattern.exec(trimmedLine)) !== null) {
                  errors.push({
                      startLineNumber: lineNum,
                      endLineNumber: lineNum,
                      startColumn: repetitionMatch.index + 1,
                      endColumn: repetitionMatch.index + repetitionMatch[0].length + 1,
                      message: item.message,
                      severity: monaco.MarkerSeverity.Error
                  });
              }
          });

          if (/\bgame\.GetService\b/.test(trimmedLine)) {
              errors.push({
                  startLineNumber: lineNum,
                  endLineNumber: lineNum,
                  startColumn: trimmedLine.indexOf('game.GetService') + 1,
                  endColumn: trimmedLine.indexOf('game.GetService') + 'game.GetService'.length + 1,
                  message: 'Method call should use a colon. Did you mean `game:GetService()`?',
                  severity: monaco.MarkerSeverity.Warning
              });
          }

          if (/\b(functionn|funtion)\b/.test(trimmedLine)) {
            errors.push({
              startLineNumber: lineNum,
              endLineNumber: lineNum,
              startColumn: trimmedLine.match(/\b(functionn|funtion)\b/).index + 1,
              endColumn: trimmedLine.match(/\b(functionn|funtion)\b/)[0].length + trimmedLine.match(/\b(functionn|funtion)\b/).index + 1,
              message: 'Possible typo: Did you mean "function"?',
              severity: monaco.MarkerSeverity.Warning
            });
          }
          
          if (/\b(lcoal)\b/.test(trimmedLine)) {
            errors.push({
              startLineNumber: lineNum,
              endLineNumber: lineNum,
              startColumn: trimmedLine.match(/\b(lcoal)\b/).index + 1,
              endColumn: trimmedLine.match(/\b(lcoal)\b/)[0].length + trimmedLine.match(/\b(lcoal)\b/).index + 1,
              message: 'Possible typo: Did you mean "local"?',
              severity: monaco.MarkerSeverity.Warning
            });
          }
          
          if (/\b(whille)\b/.test(trimmedLine)) {
            errors.push({
              startLineNumber: lineNum,
              endLineNumber: lineNum,
              startColumn: trimmedLine.match(/\b(whille)\b/).index + 1,
              endColumn: trimmedLine.match(/\b(whille)\b/)[0].length + trimmedLine.match(/\b(whille)\b/).index + 1,
              message: 'Possible typo: Did you mean "while"?',
              severity: monaco.MarkerSeverity.Warning
            });
          }
          
          if (/\b(retun|reutrn)\b/.test(trimmedLine)) {
            errors.push({
              startLineNumber: lineNum,
              endLineNumber: lineNum,
              startColumn: trimmedLine.match(/\b(retun|reutrn)\b/).index + 1,
              endColumn: trimmedLine.match(/\b(retun|reutrn)\b/)[0].length + trimmedLine.match(/\b(retun|reutrn)\b/).index + 1,
              message: 'Possible typo: Did you mean "return"?',
              severity: monaco.MarkerSeverity.Warning
            });
          }
        }

        while (endStack.length > 0) {
            var unclosed = endStack.pop();
            errors.push({
                startLineNumber: unclosed.line,
                endLineNumber: unclosed.line,
                startColumn: unclosed.column,
                endColumn: lines[unclosed.line - 1].length + 1,
                message: 'Unclosed "' + unclosed.type + '" block. Missing "end".',
                severity: monaco.MarkerSeverity.Error
            });
        }

        return errors;
      }

      // Autocomplete provider
      monaco.languages.registerCompletionItemProvider('lua', {
        provideCompletionItems: function(model, position) {
          var code = model.getValue();
          var extracted = extractVariablesAndFunctions(code);
          var variables = extracted.variables;
          var functions = extracted.functions;
          
          var line = model.getLineContent(position.lineNumber);
          var textUntilPosition = line.substring(0, position.column - 1);
          var word = model.getWordUntilPosition(position);
          
          var range = {
            startLineNumber: position.lineNumber,
            endLineNumber: position.lineNumber,
            startColumn: word.startColumn,
            endColumn: word.endColumn,
          };

          var suggestions = [];

          var keywords = [
            { label: 'and', documentation: 'Logical AND operator. Returns its first argument if it is false or nil; otherwise, returns its second argument.' },
            { label: 'break', documentation: 'Terminates the execution of a while, repeat, or for loop, and continues execution after the loop.' },
            { label: 'do', documentation: 'Starts a `do ... end` block, or part of `for` and `while` loops.' },
            { label: 'else', documentation: 'Part of an `if` statement, executed if all preceding conditions are false.' },
            { label: 'elseif', documentation: 'Combines `else` and `if` for chained conditional checks.' },
            { label: 'end', documentation: 'Closes a block (if, for, while, function, do, repeat).' },
            { label: 'false', documentation: 'Boolean literal representing falsity.' },
            { label: 'for', documentation: 'Starts a numeric or generic `for` loop.' },
            { label: 'function', documentation: 'Defines a function.' },
            { label: 'if', documentation: 'Starts a conditional `if` statement.' },
            { label: 'in', documentation: 'Used with `for` loop for iterating over iterators (e.g., `pairs`, `ipairs`).' },
            { label: 'local', documentation: 'Declares a local variable or function, limiting its scope.' },
            { label: 'nil', documentation: 'Represents the absence of a value or an undefined variable.' },
            { label: 'not', documentation: 'Logical NOT operator. Returns true if its argument is false or nil; otherwise, returns false.' },
            { label: 'or', documentation: 'Logical OR operator. Returns its first argument if it is not false or nil; otherwise, returns its second argument.' },
            { label: 'repeat', documentation: 'Starts a `repeat ... until` loop, which executes its body at least once.' },
            { label: 'return', documentation: 'Returns values from a function or from a chunk.' },
            { label: 'then', documentation: 'Part of an `if` statement, executed if the condition is true.' },
            { label: 'true', documentation: 'Boolean literal representing truth.' },
            { label: 'until', documentation: 'Ends a `repeat` loop, continuing until the condition is true.' },
            { label: 'while', documentation: 'Starts a `while` loop, which executes its body as long as its condition is true.' }
          ];

          var trimmedTextUntilPosition = textUntilPosition.trim();
          var lastWordMatch = trimmedTextUntilPosition.match(/\b([a-zA-Z_][a-zA-Z0-9_]*)\s*$/);
          var lastWord = lastWordMatch ? lastWordMatch[1] : '';

          if (trimmedTextUntilPosition === '' || /\b(end|then|do)\s*$/.test(trimmedTextUntilPosition) || textUntilPosition.endsWith(';') || /^\s*$/.test(textUntilPosition.replace(word.word, ''))) {
            if (lastWord !== 'local') {
              suggestions.push({
                label: 'local',
                kind: monaco.languages.CompletionItemKind.Keyword,
                insertText: 'local ',
                documentation: 'Declares a local variable or function, limiting its scope.',
                range: range,
                command: { id: 'editor.action.triggerSuggest', title: 'Trigger Suggest' }
              });
            }
          }

          keywords.forEach(function(kw) {
            if (lastWord === kw.label && kw.label !== 'in') {
              return;
            }
            if (kw.label === word.word) {
              return;
            }
            suggestions.push({
              label: kw.label,
              kind: monaco.languages.CompletionItemKind.Keyword,
              insertText: kw.label,
              documentation: kw.documentation,
              range: range
            });
          });

          var luaStdFunctions = [
            { label: 'assert', documentation: 'Checks if its first argument is true, otherwise raises an error.' },
            { label: 'error', documentation: 'Terminates the last protected call and returns message.' },
            { label: 'getmetatable', documentation: 'Returns the metatable of the given object.' },
            { label: 'ipairs', documentation: 'An iterator function that iterates over the numeric indices of an array-like table.' },
            { label: 'next', documentation: 'Allows traversal of all fields in a table. Used internally by `pairs`.' },
            { label: 'pairs', documentation: 'An iterator function that iterates over all key-value pairs of a table.' },
            { label: 'pcall', documentation: 'Calls a function in protected mode. Catches errors without stopping execution.' },
            { label: 'print', documentation: 'Outputs arguments to the console.' },
            { label: 'rawequal', documentation: 'Checks if two values are equal without invoking metamethods.' },
            { label: 'rawget', documentation: 'Retrieves a table element without invoking metatables.' },
            { label: 'rawset', documentation: 'Sets a table element without invoking metatables.' },
            { label: 'select', documentation: 'Returns selected arguments from a variable number of arguments.' },
            { label: 'setmetatable', documentation: 'Sets the metatable of a given table.' },
            { label: 'tonumber', documentation: 'Converts its argument to a number.' },
            { label: 'tostring', documentation: 'Converts its argument to a string.' },
            { label: 'type', documentation: 'Returns the type of its argument as a string.' },
            { label: 'unpack', documentation: 'Returns elements from a table as multiple return values.' },
            { label: 'xpcall', documentation: 'Calls a function in protected mode with an error handler.' },
            // Math
            { label: 'math.abs', documentation: 'Returns the absolute value of `x`.' },
            { label: 'math.acos', documentation: 'Returns the arc cosine of `x` (in radians).' },
            { label: 'math.asin', documentation: 'Returns the arc sine of `x` (in radians).' },
            { label: 'math.atan', documentation: 'Returns the arc tangent of `x` (in radians).' },
            { label: 'math.ceil', documentation: 'Returns the smallest integer greater than or equal to `x`.' },
            { label: 'math.cos', documentation: 'Returns the cosine of `x` (assumed to be in radians).' },
            { label: 'math.deg', documentation: 'Converts radians to degrees.' },
            { label: 'math.exp', documentation: 'Returns e^x.' },
            { label: 'math.floor', documentation: 'Returns the largest integer less than or equal to `x`.' },
            { label: 'math.fmod', documentation: 'Returns the remainder of the division of `x` by `y` that rounds the quotient towards zero.' },
            { label: 'math.huge', documentation: 'Represents the value positive infinity.' },
            { label: 'math.log', documentation: 'Returns the natural logarithm of `x`.' },
            { label: 'math.max', documentation: 'Returns the maximum of its arguments.' },
            { label: 'math.min', documentation: 'Returns the minimum of its arguments.' },
            { label: 'math.pi', documentation: 'The value of pi.' },
            { label: 'math.pow', documentation: 'Returns `x^y`.' },
            { label: 'math.rad', documentation: 'Converts degrees to radians.' },
            { label: 'math.random', documentation: 'Generates pseudo-random numbers.' },
            { label: 'math.randomseed', documentation: 'Sets the seed for the pseudo-random number generator.' },
            { label: 'math.sin', documentation: 'Returns the sine of `x` (assumed to be in radians).' },
            { label: 'math.sqrt', documentation: 'Returns the square root of `x`.' },
            { label: 'math.tan', documentation: 'Returns the tangent of `x` (assumed to be in radians).' },
            // String
            { label: 'string.byte', documentation: 'Returns the numerical ASCII value of a character in a string.' },
            { label: 'string.char', documentation: 'Converts numerical ASCII values to characters.' },
            { label: 'string.find', documentation: 'Searches for the first occurrence of a pattern in a string.' },
            { label: 'string.format', documentation: 'Returns a formatted version of its arguments.' },
            { label: 'string.gmatch', documentation: 'Creates an iterator that iterates over all occurrences of a pattern in a string.' },
            { label: 'string.gsub', documentation: 'Replaces all occurrences of a pattern in a string.' },
            { label: 'string.len', documentation: 'Returns the length of a string.' },
            { label: 'string.lower', documentation: 'Converts a string to lowercase.' },
            { label: 'string.match', documentation: 'Returns the first capture of a pattern in a string.' },
            { label: 'string.rep', documentation: 'Returns a string that is the concatenation of `n` copies of the string `s`.' },
            { label: 'string.reverse', documentation: 'Returns a reversed version of a string.' },
            { label: 'string.sub', documentation: 'Returns a substring of a string.' },
            { label: 'string.upper', documentation: 'Converts a string to uppercase.' },
            // Table
            { label: 'table.concat', documentation: 'Concatenates the elements of a table into a string.' },
            { label: 'table.insert', documentation: 'Inserts an element into a table at a specified position.' },
            { label: 'table.remove', documentation: 'Removes an element from a table at a specified position.' },
            { label: 'table.sort', documentation: 'Sorts the elements of a table.' },
            // Roblox Globals/Libraries
            { label: 'game', documentation: 'The root of the Roblox data model, representing the entire game instance.' },
            { label: 'workspace', documentation: 'A direct reference to `game.Workspace`, commonly used for accessing in-game objects.' },
            { label: 'script', documentation: 'A direct reference to the currently running `Script` or `LocalScript` instance.' },
            { label: 'shared', documentation: 'A global table accessible across multiple scripts and client/server boundaries.' },
            { label: 'print', documentation: 'Outputs arguments to the console. (Overridden by Roblox to support multiple arguments nicely)' },
            { label: 'warn', documentation: 'Outputs a warning message to the console.' },
            { label: 'error', documentation: 'Outputs an error message to the console and stops script execution. (Overridden by Roblox)' },
            { label: 'typeof', documentation: 'Returns the Luau type name of a value as a string.' },
            { label: 'delay', documentation: 'Pauses the current script execution for a given number of seconds and then resumes it in a new thread.' },
            { label: 'tick', documentation: 'Returns the number of seconds that have elapsed since the epoch (January 1, 1970) in UTC.' },
            { label: 'time', documentation: 'Returns the current game time in seconds.' },
            { label: 'version', documentation: 'Returns the current Roblox client version string.' },
            { label: 'Enum', documentation: 'Provides access to Roblox enumerations (e.g., Enum.KeyCode.W).' },
            { label: 'UDim2', documentation: 'A data type representing 2D dimensions for UI elements, with scale and offset components.' },
            { label: 'Vector2', documentation: 'A data type representing a 2D vector.' },
            { label: 'Vector3', documentation: 'A data type representing a 3D vector.' },
            { label: 'CFrame', documentation: 'A data type representing a coordinate frame (position and orientation) in 3D space.' },
            { label: 'Color3', documentation: 'A data type representing an RGB color.' },
            { label: 'BrickColor', documentation: 'A data type representing a color from Roblox\'s palette.' },
            // Roblox Services
            { label: 'game:GetService("Players")', documentation: 'Provides access to player-related services.' },
            { label: 'game:GetService("Workspace")', documentation: 'Provides access to the 3D world where parts are displayed.' },
            { label: 'game:GetService("Lighting")', documentation: 'Manages environmental lighting and effects.' },
            { label: 'game:GetService("ReplicatedStorage")', documentation: 'A container for assets replicated to both client and server.' },
            { label: 'game:GetService("ServerScriptService")', documentation: 'A container for server-side scripts that run automatically.' },
            { label: 'game:GetService("ServerStorage")', documentation: 'A container for server-side assets not replicated to clients.' },
            { label: 'game:GetService("StarterGui")', documentation: 'A container for GUI elements that are cloned to players upon joining.' },
            { label: 'game:GetService("StarterPack")', documentation: 'A container for tools that are given to players upon joining.' },
            { label: 'game:GetService("Teams")', documentation: 'Manages teams in the game.' },
            { label: 'game:GetService("SoundService")', documentation: 'Manages audio playback.' },
            { label: 'game:GetService("DataStoreService")', documentation: 'Provides methods for saving and loading player data.' },
            { label: 'game:GetService("RunService")', documentation: 'Provides events that fire every frame or physics step.' },
            { label: 'game:GetService("TweenService")', documentation: 'Creates and manages smooth property transitions.' }
          ];

          luaStdFunctions.forEach(function(func) {
            if (func.label.includes(word.word) || func.label.toLowerCase().includes(word.word.toLowerCase())) {
              suggestions.push({
                label: func.label,
                kind: monaco.languages.CompletionItemKind.Function,
                insertText: func.label,
                documentation: func.documentation,
                range: range
              });
            }
          });

          variables.forEach(function(variable) {
            if (variable.includes(word.word) || variable.toLowerCase().includes(word.word.toLowerCase())) {
              suggestions.push({
                label: variable,
                kind: monaco.languages.CompletionItemKind.Variable,
                insertText: variable,
                documentation: 'Local variable',
                range: range
              });
            }
          });

          functions.forEach(function(func) {
            if (func.includes(word.word) || func.toLowerCase().includes(word.word.toLowerCase())) {
              suggestions.push({
                label: func,
                kind: monaco.languages.CompletionItemKind.Function,
                insertText: func,
                documentation: 'Function defined in script',
                range: range
              });
            }
          });

          var snippets = [
            {
              label: 'if_else_snippet',
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: [
                'if ${1:condition} then',
                '\t${2:-- code}',
                'else',
                '\t${3:-- code}',
                'end'
              ].join('\n'),
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              documentation: 'If-Else Statement'
            },
            {
              label: 'for_i_loop',
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: [
                'for ${1:i} = ${2:1}, ${3:10} do',
                '\t${4:-- code}',
                'end'
              ].join('\n'),
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              documentation: 'Numeric For Loop'
            },
            {
              label: 'for_pairs_loop',
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: [
                'for ${1:key}, ${2:value} in pairs(${3:table}) do',
                '\t${4:-- code}',
                'end'
              ].join('\n'),
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              documentation: 'For In Pairs Loop'
            },
            {
              label: 'function_snippet',
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: [
                'function ${1:functionName}(${2:arguments})',
                '\t${3:-- code}',
                'end'
              ].join('\n'),
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              documentation: 'Function Declaration'
            },
            {
              label: 'local_function_snippet',
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: [
                'local function ${1:functionName}(${2:arguments})',
                '\t${3:-- code}',
                'end'
              ].join('\n'),
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              documentation: 'Local Function Declaration'
            },
            {
              label: 'print_snippet',
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: 'print(${1:message})',
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              documentation: 'Print Statement'
            },
            {
              label: 'local_variable_snippet',
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: 'local ${1:variableName} = ${2:value}',
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              documentation: 'Local Variable Declaration'
            },
            {
              label: 'get_service_snippet',
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: 'game:GetService("${1:ServiceName}")',
              insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
              documentation: 'Get Roblox Service'
            }
          ];

          snippets.forEach(function(snippet) {
            if (snippet.label.includes(word.word) || snippet.label.toLowerCase().includes(word.word.toLowerCase())) {
              suggestions.push(snippet);
            }
          });

          return { suggestions: suggestions };
        }
      });

      var editor = null;
      var currentModel = null;
      var tabCounter = { value: 1 };
      var editorModels = new Map();
      var activeTabId = null;

      var tabBar = document.getElementById('tab-bar');
      var editorContainer = document.getElementById('editor-container');
      var contextMenu = document.getElementById('context-menu');
      var currentContextMenuTab = null;

      function addNewTab(initialContent, tabName) {
        initialContent = initialContent || '';
        tabName = tabName || ('Untitled ' + (tabCounter.value - 1));
        
        var tabId = 'tab-' + tabCounter.value++;
        var newTab = document.createElement('div');
        newTab.className = 'tab';
        newTab.setAttribute('data-tab-id', tabId);
        newTab.setAttribute('tabindex', '0');

        var tabNameSpan = document.createElement('span');
        tabNameSpan.className = 'tab-name';
        tabNameSpan.textContent = tabName;
        newTab.appendChild(tabNameSpan);

        var closeButton = document.createElement('span');
        closeButton.className = 'close-tab';
        closeButton.textContent = 'x';
        closeButton.onclick = function(e) {
          e.stopPropagation();
          closeTab(newTab);
        };
        newTab.appendChild(closeButton);

        newTab.onclick = function() { activateTab(tabId); };
        newTab.oncontextmenu = function(e) { showContextMenu(e, newTab); };

        tabBar.insertBefore(newTab, tabBar.querySelector('.tab.new'));

        var model = monaco.editor.createModel(initialContent, 'lua');
        editorModels.set(tabId, model);

        activateTab(tabId);

        newTab.scrollIntoView(false);
      }

      function activateTab(tabId) {
        if (activeTabId === tabId) {
          return;
        }

        if (activeTabId) {
          var currentActiveTab = tabBar.querySelector('.tab[data-tab-id="' + activeTabId + '"]');
          if (currentActiveTab) {
            currentActiveTab.classList.remove('active');
          }
        }

        var newActiveTab = tabBar.querySelector('.tab[data-tab-id="' + tabId + '"]');
        newActiveTab.classList.add('active');
        activeTabId = tabId;

        var model = editorModels.get(tabId);
        if (editor) {
          editor.setModel(model);
        } else {
          editor = monaco.editor.create(editorContainer, {
            model: model,
            language: 'lua',
            automaticLayout: true,
            theme: 'gray-black',
            fontSize: 14,
            minimap: { enabled: true },
            overviewRulerBorder: false,
            scrollbar: {
              useShadows: false,
              verticalScrollbarSize: 8,
              horizontalScrollbarSize: 8,
            },
            mouseWheelZoom: true,
            wordWrap: 'on',
            lineNumbersMinChars: 3
          });

          editor.getModel().onDidChangeContent(updateMarkers);
        }
        currentModel = model;
        updateMarkers();
      }

      function closeTab(tabToClose) {
        var tabIdToClose = tabToClose.getAttribute('data-tab-id');
        editorModels.delete(tabIdToClose);
        tabToClose.parentNode.removeChild(tabToClose);

        if (activeTabId === tabIdToClose) {
          var remainingTabs = tabBar.querySelectorAll('.tab:not(.new)');
          if (remainingTabs.length > 0) {
            activateTab(remainingTabs[0].getAttribute('data-tab-id'));
          } else {
            editor.dispose();
            editor = null;
            addNewTab();
          }
        }
      }

      function renameTab(tabElement) {
        var tabNameSpan = tabElement.querySelector('.tab-name');
        var originalName = tabNameSpan.textContent;
        tabNameSpan.contentEditable = true;
        tabNameSpan.focus();
        document.execCommand('selectAll', false, null);

        var finishRename = function() {
          tabNameSpan.contentEditable = false;
          if (tabNameSpan.textContent.trim() === '') {
            tabNameSpan.textContent = originalName;
          }
          tabNameSpan.removeEventListener('blur', finishRename);
          tabNameSpan.removeEventListener('keydown', handleKeydown);
        };

        var handleKeydown = function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            finishRename();
          } else if (e.key === 'Escape') {
            tabNameSpan.textContent = originalName;
            tabNameSpan.contentEditable = false;
            tabNameSpan.blur();
            tabNameSpan.removeEventListener('blur', finishRename);
            tabNameSpan.removeEventListener('keydown', handleKeydown);
          }
        };

        tabNameSpan.addEventListener('blur', finishRename);
        tabNameSpan.addEventListener('keydown', handleKeydown);
      }

      function showContextMenu(e, tabElement) {
        e.preventDefault();
        hideContextMenu();
        currentContextMenuTab = tabElement;

        contextMenu.style.display = 'block';
        contextMenu.style.left = e.pageX + 'px';
        contextMenu.style.top = e.pageY + 'px';
      }

      function hideContextMenu() {
        contextMenu.style.display = 'none';
        currentContextMenuTab = null;
      }

      document.addEventListener('click', function(e) {
          if (!contextMenu.contains(e.target) && !e.target.classList.contains('tab')) {
              hideContextMenu();
          }
      });

      contextMenu.addEventListener('click', function(e) {
          var action = e.target.getAttribute('data-action');
          if (currentContextMenuTab && action) {
              if (action === 'rename') {
                  renameTab(currentContextMenuTab);
              } else if (action === 'delete') {
                  closeTab(currentContextMenuTab);
              }
          }
          hideContextMenu();
      });

      var newTabButton = document.createElement('div');
      newTabButton.className = 'tab new';
      newTabButton.textContent = '+';
      newTabButton.onclick = addNewTab;
      newTabButton.setAttribute('tabindex', '0');
      tabBar.appendChild(newTabButton);

      addNewTab();

      var markers = [];
      function updateMarkers() {
        if (!editor || !editor.getModel()) return;
        var model = editor.getModel();
        var code = model.getValue();
        var detectedErrors = checkLuaSyntax(code);

        monaco.editor.setModelMarkers(model, 'owner', detectedErrors);
      }
    });
  </script>
</body>
</html>
